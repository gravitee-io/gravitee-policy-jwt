/*
 * Copyright Â© 2015 The Gravitee team (http://gravitee.io)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.gravitee.policy.processing;

import com.google.common.annotations.VisibleForTesting;
import com.nimbusds.jose.JOSEException;
import com.nimbusds.jose.proc.BadJOSEException;
import com.nimbusds.jose.proc.SecurityContext;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.proc.JWTProcessor;
import io.gravitee.common.security.jwt.LazyJWT;
import io.gravitee.common.utils.UUID;
import io.gravitee.gateway.api.ExecutionContext;
import io.gravitee.gateway.reactive.api.context.ContextAttributes;
import io.gravitee.gateway.reactive.api.context.base.BaseExecutionContext;
import io.gravitee.node.api.cache.Cache;
import io.gravitee.node.api.cache.CacheConfiguration;
import io.gravitee.node.plugin.cache.common.InMemoryCache;
import java.text.ParseException;
import java.util.Date;
import lombok.extern.slf4j.Slf4j;

/**
 * Allows validating and caching the result of JWT claims set processing.
 * @author Yann TAVERNIER (yann.tavernier at graviteesource.com)
 * @author GraviteeSource Team
 */
@Slf4j
public class JWTClaimsSetValidator {

    /**
     * Defines the maximum size of the cache used for storing validated JWT claim sets.
     * This constant represents the upper limit on the number of entries the cache can hold at any given time.
     *
     * Aims to prevent excessive memory usage by capping the number of cached JWT claim sets.
     * It is applied in the cache configuration when creating the cache instance for validated claims.
     */
    private static final int CACHE_MAX_SIZE = 1_000;

    /**
     * Defines the time in milliseconds an entry in the cache can remain idle before being considered stale and subject to eviction.
     * This value determines the maximum duration of inactivity for a cached item, which is the time between the last access
     * and the next before the item is removed from the cache. It helps in managing memory usage by clearing unused entries.
     *
     * The value is set to 5 minutes (300,000 milliseconds).
     */
    private static final int CACHE_TIME_TO_IDLE_MS = 5 * 60 * 1_000;

    @VisibleForTesting
    protected final Cache<String, JWTClaimsSet> validClaimsSetCache;

    private JWTClaimsSetValidator(String apiId) {
        this.validClaimsSetCache =
            new InMemoryCache<>(
                "JWT_%s_%s".formatted(apiId, UUID.random().toString()),
                CacheConfiguration.builder().maxSize(CACHE_MAX_SIZE).timeToIdleInMs(CACHE_TIME_TO_IDLE_MS).build()
            );
    }

    public static JWTClaimsSetValidator create(BaseExecutionContext ctx) {
        return new JWTClaimsSetValidator(ctx.getAttribute(ContextAttributes.ATTR_API));
    }

    public static JWTClaimsSetValidator create(ExecutionContext ctx) {
        return new JWTClaimsSetValidator((String) ctx.getAttribute(ExecutionContext.ATTR_API));
    }

    /**
     * Extracts and validates the {@link JWTClaimsSet} from the provided {@link LazyJWT} using the given {@link JWTProcessor}.
     * The method checks if there is a cached valid claims set for the given token and returns it if it has not expired.
     * Otherwise, it processes the token to generate a new valid claims set, caches it, and returns it.
     *
     * @param jwtProcessor the {@link JWTProcessor} responsible for processing the {@link LazyJWT} and extracting its claims.
     * @param jwt the {@link LazyJWT} instance containing the token to be processed.
     * @return the validated {@link JWTClaimsSet}, either retrieved from the cache or generated by the provided {@link JWTProcessor}.
     * @throws BadJOSEException if the JWT is invalid or fails to meet the security requirements during processing.
     * @throws JOSEException if an error occurs while handling the JOSE object.
     */
    public JWTClaimsSet extract(JWTProcessor<SecurityContext> jwtProcessor, LazyJWT jwt) throws BadJOSEException, JOSEException {
        String token = jwt.getToken();
        JWTClaimsSet cachedJwtClaimsSet = validClaimsSetCache.get(token);
        if (cachedJwtClaimsSet != null) {
            if (hasNotExpired(cachedJwtClaimsSet.getExpirationTime())) {
                return cachedJwtClaimsSet;
            }
            validClaimsSetCache.evict(token);
        }
        JWTClaimsSet validClaimsSet = jwtProcessor.process(jwt.getDelegate(), null);
        validClaimsSetCache.put(token, validClaimsSet);
        return validClaimsSet;
    }

    /**
     * Extracts and validates the {@link JWTClaimsSet} from the provided JWT token using the given {@link JWTProcessor}.
     * The method checks if there is a cached valid claims set for the given token and returns it if it has not expired.
     * If no valid cached claims set exists or it has expired, the token is processed to generate a new valid claims set,
     * which is then cached and returned.
     *
     * @param jwtProcessor the {@link JWTProcessor} responsible for processing the JWT token and extracting its claims
     * @param token the string representation of the JWT token to be processed
     * @return the validated {@link JWTClaimsSet}, either retrieved from the cache or generated by the provided {@link JWTProcessor}
     * @throws BadJOSEException if the JWT is invalid or fails to meet the security requirements during processing
     * @throws JOSEException if an error occurs while handling the JOSE object
     */
    public JWTClaimsSet extract(JWTProcessor<SecurityContext> jwtProcessor, String token) throws BadJOSEException, JOSEException {
        JWTClaimsSet cachedJwtClaimsSet = validClaimsSetCache.get(token);
        if (cachedJwtClaimsSet != null) {
            if (hasNotExpired(cachedJwtClaimsSet.getExpirationTime())) {
                return cachedJwtClaimsSet;
            }
            validClaimsSetCache.evict(token);
        }
        try {
            JWTClaimsSet validClaimsSet = jwtProcessor.process(token, null);
            validClaimsSetCache.put(token, validClaimsSet);
            return validClaimsSet;
        } catch (ParseException e) {
            throw new JOSEException("Failed to parse JWT while extracting claims", e);
        }
    }

    /**
     * Invalidates the cache entry for the given LazyJWT token.
     * This ensures that the token's associated claims set is no longer considered valid
     * and will need to be reprocessed to extract or validate its claims in subsequent operations.
     *
     * @param jwt the LazyJWT instance whose associated cached claims set will be invalidated
     * @return
     */
    public JWTClaimsSet invalidate(LazyJWT jwt) {
        return invalidate(jwt.getToken());
    }

    /**
     * Invalidates the cache entry for the given token string.
     * @param token the raw JWT token
     * @return the previously cached claims if any
     */
    public JWTClaimsSet invalidate(String token) {
        return validClaimsSetCache.evict(token);
    }

    /**
     * Checks if the provided expiration time has not expired, accounting for a default clock skew.
     * It reuses the same clock skew as used by the DefaultJWTClaimsVerifier class.
     *
     * @param expirationTime the expiration time to validate
     * @return true if the provided expiration time is not null and has not expired based on the current system time
     */
    private static boolean hasNotExpired(Date expirationTime) {
        // Default clock skew in nimbus-jose-jwt's DefaultJWTClaimsVerifier is 60 seconds.
        long maxClockSkewInMs = 60 * 1000L;
        return expirationTime != null && expirationTime.getTime() > (System.currentTimeMillis() - maxClockSkewInMs);
    }
}
